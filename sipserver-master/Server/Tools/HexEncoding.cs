using System;
using System.Text;
using Sip.Message;
using Base.Message;

public static class HexEncoding
{
	public static char[] HexToLowerChar = new char[16] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', };
	public static byte[] HexToLowerAsciiCode = new byte[16] { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66 };

	public static string ToHexString(this byte[] bytes, int offset, int length)
	{
		StringBuilder sb = new StringBuilder(bytes.Length * 2);

		for (int i = 0; i < length; i++)
		{
			sb.Append(HexToLowerChar[bytes[offset + i] >> 4]);
			sb.Append(HexToLowerChar[bytes[offset + i] & 0x0f]);
		}

		return sb.ToString();
	}

	public static void GetLowerHexChars(byte[] src, int srcOffset, int srcLength, byte[] dst, int dstOffset)
	{
		int offset = srcOffset;

		for (int i = 0; i < srcLength; i++)
		{
			dst[dstOffset++] = HexToLowerAsciiCode[src[srcOffset] >> 4];
			dst[dstOffset++] = HexToLowerAsciiCode[src[srcOffset++] & 0x0f];
		}
	}

	public static void GetLowerHexChars(byte[] src, byte[] dst)
	{
		int offset = 0;

		for (int i = 0; i < src.Length; i++)
		{
			dst[offset++] = HexToLowerAsciiCode[src[i] >> 4];
			dst[offset++] = HexToLowerAsciiCode[src[i] & 0x0f];
		}
	}

	public static void GetLowerHexChars(int value, byte[] dst)
	{
		GetLowerHexChars(value, dst, 0);
	}

	public static void GetLowerHexChars(int value, byte[] dst, int dstOffset)
	{
		int offset = dstOffset + 8;

		for (int i = 0; i < 8; i++, value >>= 4)
			dst[--offset] = HexToLowerAsciiCode[value & 0x0f];
	}

	public static byte ParseHex2(ByteArrayPart part, int offset)
	{
		byte result = 0xff;

		if (part.IsValid && part.Length - offset >= 2)
		{
			result = AsciiCodeToHex[part.Bytes[part.Offset + offset]];
			result <<= 4;
			result |= AsciiCodeToHex[part.Bytes[part.Offset + offset + 1]];
		}

		return result;
	}

	public static bool TryParseHex2(ByteArrayPart part, int offset, out byte result)
	{
		if (part.IsValid && part.Length - offset >= 2)
		{
			byte b1 = AsciiCodeToHex[part.Bytes[part.Offset + offset]];
			byte b2 = AsciiCodeToHex[part.Bytes[part.Offset + offset + 1]];

			if (b1 != 0xff && b2 != 0xff)
			{
				result = b1;
				result <<= 4;
				result |= b2;
				return true;
			}
		}

		result = 0;
		return false;
	}

	public static int? ParseHex8(ByteArrayPart part)
	{
		int result;
		if (part.IsValid && part.Length == 8)
			if (TryParseHex8(part.Bytes, part.Begin, out result))
				return result;
		return null;
	}

	public static bool TryParseHex8(ByteArrayPart part, out int result)
	{
		if (part.IsValid && part.Length == 8)
			return TryParseHex8(part.Bytes, part.Begin, out result);
		result = -1;
		return false;
	}

	public static bool TryParseHex8(byte[] bytes, int startIndex, out int result)
	{
		int digit;
		result = 0;

		for (int i = 0; i < 8; i++)
		{
			digit = AsciiCodeToHex[bytes[startIndex + i]];
			if (digit > 0x0f)
				return false;

			result = (result << 4) | digit;
		}

		return true;
	}

	public static int TryParseHex(ArraySegment<byte> source, byte[] dest)
	{
		if ((source.Count & 1) != 0)
			return -1;

		if (source.Count / 2 > dest.Length)
			return -1;

		byte digit;
		for (int i = 0; i < source.Count; i++)
		{
			digit = AsciiCodeToHex[source.Array[source.Offset + i]];
			if (digit > 0x0f)
				return -1;

			int j = i / 2;
			dest[j] <<= 4;
			dest[j] |= digit;
		}

		return source.Count / 2;
	}

	public static readonly byte[] AsciiCodeToHex = new byte[256] { 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		};
}
